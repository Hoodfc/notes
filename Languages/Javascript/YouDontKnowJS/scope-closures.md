# You Don't Know JS - Scope & Closures

## 1. What is Scope?

The ability to store values in variables, and later read and modify them, is one of the fundamental in every program. But where do variables _live_? How does our program find them when it needs them?

The **scope** represents the set of rules that answers these questions.

### Compiler Theory

Despite the fact that Javascript is described as a "_dynamic_" or "_interpreted_" language, it is in fact a **compiled language**. It is not compiled in advance, and the results in compiling cannot be shared among distributed systems as the other traditional languages, but it is compiled. Compilation can be summed into three major steps:

1.  **Lexing / Tokenizing**

Breaking up a stream of characters into meaningful tokens

2.  **Parsing**

Taking a stream of tokens and turning it into a tree nested elements, rapresenting the grammatical structure of our program. This tree is called **Abstract Syntax Tree** (AST).

3.  **Code-Generating**

The process of taking an AST and turn it into executable (machine) code.

Javascript's compiling process is much more complex, but this should give the idea. What separates JS from the other compiled languages is that it doesn't have the **luxury** to take a lot of time to optmize the code, because it compiles the code just before its execution.

### Understanding Scope

Scope can be rapresented as a conversation between three characters:

1.  **Engine**

Responsible for compilation and execution of our program

2.  **Compiler**

Handles all of the parsing and code-generation for the Engine

3.  **Scope**

Collects and maintains a list of the declared identifiers (variables) and enforces a set of rules as to how these identifiers can be accessed.

#### Back and Forth & Compiler Speak

When Engine sees the program `var a = 2;` it sees two differents statements: one that's taken care by Compiler, and one by the Engine itself. Compiler will tokenize the string and then **(1)** ask to Scope whether or not an identifier `a` already exists in that particular Scope collection. Otherwise, Compiler asks Scope to add that identifier in its list. **(2)** Compiler generates the code to be executed by Engine for the `a = 2` assignement.

Engine will later checks if the variable exists in the scope, and if it does, it will assign the value of 2.

Engine can perform two types of look-ups when it executes the code generated by Compiler: **LeftHand Side** (LHS) and **RightHand Side** (RHS). LHS is done when Engine needs the **container** of the variable, RHS when only the **value** of the variable is needed.

### Nested Scope

There are usually more than one scope to consider; so if a variable is not found in the immediate scope, Engine asks to the next outercontaining one, continuing until it finds the outermost scope (which is the global one).

Consider the following:

```javascript
function foo(a) {
  console.log(a + b);
}

var b = 2;

foo(2);
```

The _RHS_ reference for `b` cannot be resolved inside `foo`, but it can in the next one - in this case the global one.

Nested scope can be thought as a tall building with multiple floors, where the first floor is the currently executing scope and the last is the global. Engine resolves _LSH_ and _RHS_ references by looking on its current floor, and if it doesn't find it, taking the elevator to the next floor. Once on the top floor, it either finds the reference there or it stops looking.

### Errors

There is an important difference between RHS and LHS in how Engine faces errors, in _non-Strict_ mode .

If a RHS reference fails to find a variable in the scope this results in a `Reference Error`; if Engine don't find a LHS reference even in the _top floor_, Scope will create a variable of that name in the global scope. In Strict Mode, added in **ES5**, the latter will results in a `ReferenceError`, while a failed RHS will result in a `TypeError`.

## 2. Lexical Scope

There are two predominant models for how scope works: the **lexical scope**, which is the one that Javascript uses and so the one we'll focus on, and the **dynamic scope**, that is used by other programming languages.

### Lex-time

The **lexical scope** is based on where variables and blocks are defined, by the programmer, at write-time; and thus are sets in stone by the time the lexer processes the code. Consider this code:

```javascript
function foo(a) {
  var b = a * 2;
  function bar(c) {
    console.log(a, b, c);
  }
  bar(b * 3);
}
foo(2);
```

There are three nested scopes:

1.  The global scope, with only the `foo` identifier
2.  The `foo` scope, with `a` , `b` and `bar` identifiers
3.  The `bar` scope, with the only identifier `c`

The scope of bar is contained in the scope of foo, because that's how we decided to defined it. The scopes are **strictly** nested, so no scope can be nested in two scopes.

### Cheating Lexical

Javascript has two mechanisms to cheat (or better _modify_) the lexical scope at runtime. Both these methods are frowned upon by the _JS_ community as bad practice that leads to **bad code**; but more importantly these methods leads to something worse: **bad perfomance**.

The **eval** function in Javascript takes a string as an argument and treats that string as if it is written code at that point in the program. It's clear that eval allows the programmer to modify lexical scope by dynamically (during code execution and not lexing time) changing it. **In general**, dynamically generated code is almost never useful and is a threat to performances.

The other way to cheat the lexical scope is by using the **with** keyword. It can be explained as a shortand to reference multiple properties of an object without having to repeat the object itself. For example:

```javascript
obj.a = 1;
obj.b = 2;
obj.c = 3;

with (obj) {
  a = 1;
  b = 2;
  c = 3;
}
```

The problem with **with** is that if it doesn't find the property in the object, it will create a variable with that name in the global scope.

#### Perfomance

As we said, the biggest problem that `eval` and `with` creates is perfomance-wise. Thats's because, as previously stated, the Javascript engine does a lot of optimization during the Compiling time, but it cannot do that when it encounters one of those two, because with there is the possibility that after their execution the lexical scope will be modified. So, even a single one eval or with can severly drop you program speed.
In **Strict Mode** both `eval` and `with` are limited: the first it can be used only in safe ways (not modifying the lexical scope), while the second is entirely banned.

## 3. Function Vs Block Scope

What makes a new _bubble_ of scope? Is it only functions? Or can other structures do it as well?  
The most common answer is that JS has function-based scope: that is, each function you declare creates a _bubble_ of scope, but no other structure can. This is not quite true, but let's first explore function scope.

### Scope From Functions

Function scope encourages the idea that all variables belogn to the function, and can be used and reused throughout its entirety (and to its nested scopes). This design approach can be quite useful, but without proper precautions, it can lead to some problems.

### Hiding in Plain Scope

A function has the result of hiding every declaration (variables or functions) inside of it. Why is that useful? For the **Principle of Least Privilege** (also called **Least Exposure**) states that in the design of software, a programmer should expose only what is minimally necessary, and hide everything else. For example:

```javascript
function doSomething(a) {
  b = a + doSomethingElse(a * 2);
  console.log(b * 3);
}

function doSomethingElse(a) {
  return a - 1;
}

var b;
doSomething(2);
```

Here, both the `b` variable and the `doSomethingElse` function are private details of how `doSomething` works. Giving access to them is **unnecessary** and **dangerous**.
This is clearly better:

```javascript
function doSomething(a) {
  function doSomethingElse(a) {
    return a - 1;
  }
  var b;
  b = a + doSomethingElse(a * 2);
  console.log(b * 3);
}
doSomething(2);
```

Another benefit of _hiding_ variables and functions inside a scope is to avoid **collision** between two identifiers with the same name but different purposes. This results in unexpected overwritings, but it can be avoided with shadowing inside nested scopes, as previously stated. **Collision** is especially common inside the global scope, becuase third-party code can pollute it with (common) identifiers without you knowing it. In order to avoind it, usally libraries will create a single and unique identifier that acts like a **global namespace**.

### Functions as Scopes

As we saw using functions is useful to hide any enclosed identifier. This method pollutes the global scope with the identifier of the function, and we need to explicitly call the function to execute it. This is a bit of overload if we did not intend to reuse the function later in code, but only hide something from the outer scope. _Javascript_ has a solution for this type of problem:

```javascript
var a = 2;

(function foo() {
  var a = 3;
  console.log(a); // 3
})();

console.log(a); // 2
```

By wrapping `foo` this way, we enclose it in the expression, avoiding polluting the global scope.

#### Anonymous Versus Named

```javascript
setTimeout(function() {
  console.log("I waited ");
}, 1000);
```

`function()` has no identifier on it, so this is called _anonymous function expression_. **Function expressions can be anonymous, function declarations cannot**. Anonymous function are used a lot, but have their drawbacks:

1. No name to display in the stack traces, so they're difficult to debug
2. Impossible to use recursion in them without using `arguments.calee`, which looks quite bad.
3. Names are used to make the code more readable.
   **Best Practice:** Always name function expressions.

```javascript
setTimeout(function timeoutHandler() {
  console.log("I waited ");
}, 1000);
```

By putting a pair of `()` after a function expression, it executes immediately without the need to call it. This method is so common that has taken is own name, **IIFE** (Immediately Invoked Function Expression).

### Blocks as Scopes

While functions are the most commont unit of scope, other units are possible (especially in an ES6+ environment). Take for example the `for` loop.

```javascript
for (var i = 0; i < 10; i++) {
  // do something
}
```

The variable `i` exists only in the loop, that acts a block scope in Javascript, as well as other programming languages. Sadly, `if` is not block-scoped, so declaring a variable inside an if does not equal to a conditional declaration, but only to a stylistic option. Block-scoping extend the Principle of Least Privilege by hiding information in blocks. Other way for block scoping:

1. ### **with**
   While frowned-upon construct, it is an example of block scope: the scope created from the object exists only in that `with` statement.
2. ### **try/catch**
   Since **ES3**, the variable declaration inside the `catch` clause is block-scoped to the catch block.
3. ### **let**
   Until **ES6**, Javascript has only the aforementioned niche behaviours for block-scoping. But that changed with the introduction of a new keyword, `let`, a new way (other than `var`) to declare variables. The `let` keyword attaches the declaration of the variable to the scope of whatever block it's contained in. Thanks to `let`, conditional declarations inside an `if` statement are possible.
   ```javascript
   if (true) {
     let foo = 2;
     //
   }
   console.log(foo); // ReferenceError
   ```
   While useful, realizing whether a block is block-scoped or not can be a bit difficult when reading the code, so it's preferable a more explicit method:
   ```javascript
   if (true) {
     {
       // explicit block scope inside the 'if' block
       let foo = 2;
       //
     }
   }
   ```
4. ### **const**
   In addition to let, _ES6_ introduced another keyword, **const**. It also creates a block scope, but its value is immutable after the first assignment.

## 4. Hoisting

As we've seen in the previous chapter, variables are attached the the closest scope. But there's a subtle detail of how the attachment of a variable to a scope works with declaration that appears in various locations.

### Chicken or the Egg?

Consider the two following snippets of code:

```javascript
a = 2;
var a;
console.log(a); // 2
```

```javascript
console.log(a); // undefined
var a = 2;
```

Both have unexpected behaviors, that lies in how declaration within a scope works.

### The Compiler Strikes Again

We stated in Chapter 1 that the _JS_ Engine compiles the code before its execution and the Compiler is responsible in some optimization and changing in our code.
One of these, all the declarations - both variables and functions - are processed first, before any other part of the code. In light of this, the two snippets can be tought as:

```javascript
var a;
a = 2;
console.log(a); // 2
```

```javascript
var a;
console.log(a); // undefined
a = 2;
```

> ### This process by the compiler is called _Hoisting_
>
> It is important to note that **hoisting** is _per-scope_, so declarations are "moved" at the beginning of the scope they are attached onto.

### Functions First

Functions' declarations are hoisted first than variables'. Because of this:

```javascript
foo(); // 1
var foo;

function foo() {
  console.log(1);
}

foo = function() {
  console.log(2);
};
```

Has as an output **1**.

> While duplicate `var` declarations are ignored, subsequent `function` declarations override previous ones. Multiple definitions on the same scope are always a bad idea.

## 5. Scope Closure

Scopes are an important, but _elusive_ and almost _mythogical_ part of Javascript. But with the knowledge of how lexical scope works, they should be way more easy to comprehend.

### Enlightenment

Although even more experienced Javascript programmer sometime struggle with the notion of closures, the reality is that in JS **closures are all around you, so you have to recognize it and embrace it**. They happen as a result of writing code that relies on the lexical scope; it's not necessary to intentionally write them, they just happen.

### Nitty Gritty

> Closure is when a function is able to remember and access its lexical scope even when that function is executing outside its lexical scope.

Let's consider:

```javascript
function foo() {
  var a = 2;
  function bar() {
    console.log(a);
  }
  return bar;
}
var baz = foo();
baz(); // 2
```

The function `bar` has access to the inner scope of foo, but then we pass `bar` itself as a value and assign it to the variable `baz`. At this point, the execution of `foo` is over, so is its scope went away, deleted by the _JS_ garbage collector? Clearly not, since when we execute `baz` the function has still the ability to perform an RHS look-up to the variable `a`, attached to the scope of `foo`. **This is a closure**.

> Closure lets function continue to access the lexical scope it was defined in at author time.

### Now I Can See

The last example is a bit academic, let's see something more practical:

```javascript
function wait(message) {
  setTimeout(function timer() {
    console.log(message);
  }, 1000);
}

wait("Hello, closure!");
```

`timer` has a closure over the scope of `wait` for the variable `message`; so after 1s when it executes, it can display the message, even though the execution `wait` is long over.

> Whenever you treat function as first-class values and pass them around (the so called _callback_ functions), you are likely to see closures.

### Loops and Closure

```javascript
for (var i = 0; i <= 5; i++) {
  setTimeout(function timer() {
    console.log(i);
  }, i * 1000);
}
```

With this loop the console will print five times **6**. Why? First, 6 is the value printed because the loop will end its execution when `i` is greater than **5**, so the first time that condition is true is when `i` is **6**. Then, every timeout callbacks are called after the loop execution, since they put on hold.

The problem is that conceptually the code implies that every loop _captures_ its own version of the timeout callback; but that's not how lexical scope works, since they all share the same global scope. What we need is a new closured scope. Here's how:

```javascript
for (let i = 0; i <= 5; i++) {
  setTimeout(function timer() {
    console.log(i);
  }, i * 1000);
}
```

Saw the difference? As stated in the previous chapter, the ES6 new keyword `let` creates a block scope wherever it is used. For pre-ES6 code, IIFE could be used - to with a more verbose result.

```javascript
for (var i = 0; i <= 5; i++) {
  (function(j) {
    setTimeout(function timer() {
      console.log(j);
    }, j * 1000);
  })(i);
}
```

### Modules

A code patter that takes advantage of closure is the _module pattern_, also called the _revealing pattern_.

```javascript
function SimpleModule() {
  var something = "something";
  var another = [1, 2, 3];
  function doSomething() {
    console.log(something);
  }

  function doSomethingElse() {
    console.log(another.join("!"));
  }

  return {
    doSomething: doSomething,
    doSomethingElse: doSomethingElse
  };
}

var foo = SimpleModule;
foo.doSomething; // something
foo.doSomethingElse; // 1!2!3!
```

`SimpleModule` is just a function and it has to be invoked for there to be a _module_ instance. The instance then thanks to closure can access to the scope of `SimpleModule`. Modules, being regular functions, can have arguments that modify their behaviours ( `AnotherModule(id, name, email)`).

#### Modern Modules

_ES6_ adds first-class support for modules. ES6 modules don't have an inline format, so each modules have to be declared in its own seperate file.

```javascript
// bar.js
function bar(who){
    return "Let me introduce" + who;
}
export bar;

// foo.js
import bar from 'bar';
console.log(hello("someone"));
```
